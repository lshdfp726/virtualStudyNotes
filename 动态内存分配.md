### 动态内存分配

#### 堆区

​	匿名内存映射分配的一块区域，即二进制零区域， 

​	动态内存分配器将堆视为一组不同大小的块的集合来维护，每个快就是一个连续的虚拟内存片，要么是已分配，要么是空闲， 一个已分配的块要么由程序显示执行释放，要么是内存分配器自身隐式执行释放。

#### 显示分配器

 	C标准库里面的 malloc 和 free ， C++ 中的new 和delete。

​	分配器分配出来的内存一定是字节对齐的，这样才能容纳任何数据结构。具体几字节对齐就看编译代码是在32为还是64位,32位 = 4字节(一个字) * 8，返回块地址是8的倍数。 64位 = 4字节（一个字） * 16 ，返回快地址是16的倍数。 （这里前提不管是32 还是64位 一个字就定义为4字节）。

​	字的大小定义和计算机体系结构有关，32位 一个字 = 4字节， 64位 一个字= 8字节，这是通常定义，具体取决于计算机硬件设定。

#### 隐式分配器

​	要求分配器检测一个已分配块何时不在被程序所使用，那么就释放这个块，即垃圾收集器。自动释放未使用的已分配的块的过程叫垃圾收集 

#### 分配器的设计目标

​	最大化吞吐率和最大化内存利用率

​	最大化吞吐率：单位时间调用分配请求和释放请求的次数。

​	最大化内存利用率：尽量把每一块内存都利用到

​	个人理解: 两者是互斥的原因是最大化吞吐率不站在内存利用率的角度考虑问题，所以只要能短时间多调用分配和释放请求即达到目标，这样就会造成内存碎片，而最大化内存利用率是想着怎样把内存碎片这些都利用起来，那么必须要有些策略去整理记录内存碎片，这等于 分配器在调用分配和释放的情况下加上整理碎片的策略，所以优秀的分配器是找到两者的平衡。

#### 分配器平衡

  1、空闲块组织，如果记录空闲块？

  2、放置:  如何选择一个适合的空闲块来放置一个新分配的块？

  3、分割：在将一个新分配的块放置到某个空闲块之后，我们如何处理这个空闲块中的剩余部分？

  4、合并，我们如何处理一个刚刚被释放的块？

  #### 空闲块组织

![截屏2023-12-27 11.56.18](/Users/fu-mobile/Library/Application Support/typora-user-images/截屏2023-12-27 11.56.18.png)

#### 分割空闲块

 	分配器通常会选择将这个空闲块分割为两部分，第一部分变为分配块，剩下的变成一个新的空闲块。如果分配器不能为请求找到合适的空闲块，那么先合并那些在内存中物理上相邻的空闲块来创建一些更大的空闲块。如果还是不能满足要求，或者空闲块已经最大程度地合并了，分配器就调用sbrk函数，向内核请求额外的堆内存。分配器将额外的内存转化为一个大的空闲块。插入到空闲链表中，然后将请求的块放置在这个新的空闲块中。

#### 合并空闲块

 	当分配器释放一个已分配的块时，可能有其他空闲块与这个新释放的空闲块相邻，这些邻接的空闲块可能引起一种现象叫假碎片。这种假碎片就有可能引起空闲块不足的情况，所以分配器必须合并相邻的空闲块。 这就涉及到一个策略：分配器可以选择立即合并，也就是在每次块被释放时就立即合并所有的相邻块。它也可以选择推迟合并，直到某个分配请求失败，然后扫描整个堆，合并所有空闲块。

 	立即合并通常在常数时间内执行完成，但对于某些请求模式(例如经常性的申请”小”内存)，立即合并就会产生抖动，块反复的合并，然后马上又分割。所以推迟合并通常在实际应用中更普片。

 	合并当前块的下一个空闲块很简单，通过头部信息里面指向下一个链表的指针来确定下个链表结点是否空闲，空闲就立即合并。但是这无法合并前一个空闲块。为了快速合并前一个块，就需要一些前一个块的额外脚部标记信息，这种技术就叫做边界标记。